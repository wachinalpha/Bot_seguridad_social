import os
import sys
from pathlib import Path

# Try to import pathspec, otherwise we will install it in main
try:
    import pathspec
except ImportError:
    pathspec = None

# Configuration
OUTPUT_FILE = "context_dump.txt"
MAX_FILE_SIZE_KB = 500  # Skip huge files
INCLUDED_EXTENSIONS = {
    ".py", ".md", ".json", ".toml", ".yml", ".yaml", 
    ".js", ".jsx", ".ts", ".tsx", ".css", ".html", 
    ".txt", ".sh", ".dockerfile", "Dockerfile", ".env.example"
}
# Always ignore these, even if not in gitignore
ALWAYS_IGNORE = {
    ".git", ".venv", "__pycache__", "node_modules", 
    "dist", "build", "coverage", ".pytest_cache", 
    "package-lock.json", "uv.lock", "yarn.lock", 
    "context_dump.txt", "Wiki.pdf"
}

def load_gitignore(root_dir: Path):
    gitignore = root_dir / ".gitignore"
    if gitignore.exists():
        with open(gitignore, "r", encoding="utf-8") as f:
            return pathspec.PathSpec.from_lines("gitwildmatch", f)
    return pathspec.PathSpec.from_lines("gitwildmatch", [])

def get_tree_structure(root_dir: Path, spec) -> str:
    tree = []
    for root, dirs, files in os.walk(root_dir):
        # Filter directories in place
        dirs[:] = [d for d in dirs if not (d in ALWAYS_IGNORE or spec.match_file(os.path.relpath(os.path.join(root, d), root_dir)))]
        
        level = root.replace(str(root_dir), "").count(os.sep)
        indent = " " * 4 * (level)
        tree.append(f"{indent}{os.path.basename(root)}/")
        subindent = " " * 4 * (level + 1)
        for f in files:
            rel_path = os.path.relpath(os.path.join(root, f), root_dir)
            if not spec.match_file(rel_path) and f not in ALWAYS_IGNORE:
                 tree.append(f"{subindent}{f}")
    return "\n".join(tree)

def build_context(root_dir: Path):
    spec = load_gitignore(root_dir)
    output_path = root_dir / OUTPUT_FILE
    
    with open(output_path, "w", encoding="utf-8") as out:
        # Header
        out.write("# PROJECT CONTEXT DUMP\n")
        out.write(f"# Generated by tools/context_builder.py at {os.environ.get('USERNAME', 'User')}")
        out.write("\n\n")
        
        # Tree Structure
        out.write("## DIRECTORY STRUCTURE\n")
        out.write("```\n")
        out.write(get_tree_structure(root_dir, spec))
        out.write("\n```\n\n")
        
        # File Contents
        out.write("## FILE CONTENTS\n\n")
        
        for root, dirs, files in os.walk(root_dir):
            # Filter directories
            dirs[:] = [d for d in dirs if not (d in ALWAYS_IGNORE or spec.match_file(os.path.relpath(os.path.join(root, d), root_dir)))]
            
            for file in files:
                file_path = Path(root) / file
                rel_path = file_path.relative_to(root_dir)
                
                # Checks
                if file in ALWAYS_IGNORE:
                    continue
                if spec.match_file(str(rel_path)):
                    continue
                if file_path.suffix not in INCLUDED_EXTENSIONS and file not in INCLUDED_EXTENSIONS:
                    continue
                if file_path.stat().st_size > MAX_FILE_SIZE_KB * 1024:
                    out.write(f"### [FILE] {rel_path} (SKIPPED: Too large)\n\n")
                    continue
                
                # Write Content
                try:
                    with open(file_path, "r", encoding="utf-8") as f:
                        content = f.read()
                        
                    out.write(f"### [FILE] {rel_path}\n")
                    out.write("```" + (file_path.suffix.replace(".", "") or "text") + "\n")
                    out.write(content)
                    out.write("\n```\n\n")
                    print(f"Added: {rel_path}")
                except Exception as e:
                    print(f"Error reading {rel_path}: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        root = Path(sys.argv[1])
    else:
        # Default to parent of 'tools' if run from there, or current dir
        current = Path.cwd()
        if current.name == "tools":
            root = current.parent
        else:
            root = current
            
    print(f"Building context from: {root}")
    
    if pathspec is None:
        print("Installing pathspec...")
        import subprocess
        subprocess.check_call([sys.executable, "-m", "pip", "install", "pathspec"])
        try:
            import pathspec as ps
            globals()['pathspec'] = ps
        except ImportError:
            print("Failed to import pathspec after installation.")
            sys.exit(1)

    build_context(root)
    print(f"Context dump created at {root / OUTPUT_FILE}")
